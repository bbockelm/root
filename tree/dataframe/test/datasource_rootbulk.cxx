#include <TBufferFile.h>
#include <ROOT/RDataFrame.hxx>
#include <ROOT/RRootBulkDS.hxx>
#include <ROOT/TTreeReaderFast.hxx>
#include <ROOT/TTreeReaderValueFast.hxx>
#include <ROOT/TBulkBranchRead.hxx>
#include <ROOT/TSeq.hxx>

#include <gtest/gtest.h>

#include <algorithm> // std::accumulate
#include <iostream>

using namespace ROOT;
using namespace ROOT::RDF;
using namespace ROOT::RDF::Experimental;

auto fileName0 = "RRootBulkDS_input_0.root";
auto fileGlob = "RRootBulkDS_input_*.root";
auto fileNameBig = "RRootBulkDS_input_big.root";
auto treeName = "t";

auto eventCount = 10;
auto bigEventCount = 100e6;
auto bigFlushSize = 50e3;
const auto kSlots = 4U;

TEST(RRootBulkDS, GenerateData)
{
   int i = 0;
   // TODO: re-introduce multiple files so we can test globbing.
   for (auto &&fileName : {fileName0}) {
      RDataFrame tdf(eventCount);
      tdf.Define("i", [&i]() { return i++; })
         .Snapshot<int32_t>(treeName, fileName, {"i"});
   }

   // Manually create a larger file, allowing us to closely control its formatting.
   auto hfile = new TFile(fileNameBig, "RECREATE", "TTree float micro benchmark ROOT file");
   hfile->SetCompressionLevel(0); // No compression at all.

   // Otherwise, we keep with the current ROOT defaults.
   auto tree = new TTree("t", "A ROOT tree of floats.");
   tree->SetAutoFlush(bigFlushSize);
   tree->SetBit(TTree::kOnlyFlushAtCluster);
   int f = 2;
   tree->Branch("myInt", &f, 320000, 1);
   for (Long64_t ev = 0; ev < bigEventCount; ev++) {
      tree->Fill();
      f ++;
   }
   hfile = tree->GetCurrentFile();
   hfile->Write();
   tree->Print();
   //printf("Successful write of all events.\n");
   hfile->Close();
   delete hfile;
}


// Test that the bulk APIs can actually read the data generated by RDF.
TEST(RRootBulkDS, DirectBulkRead)
{
   auto hfile = TFile::Open(fileName0);
   printf("Starting read of file %s.\n", fileName0);
   TStopwatch sw;

   printf("Using inline bulk read APIs.\n");
   TBufferFile branchbuf(TBuffer::kWrite, 32*1024);
   TTree *tree = dynamic_cast<TTree*>(hfile->Get("t"));
   ASSERT_TRUE(tree);

   TBranch *branchI = tree->GetBranch("i");
   ASSERT_TRUE(branchI);

   Int_t events = eventCount;
   Long64_t evt_idx = 0;
   while (events) {
      auto count = branchI->GetBulkRead().GetEntriesSerialized(evt_idx, branchbuf);
      ASSERT_EQ(count, eventCount);
      events = events > count ? (events - count) : 0;

      int *entry = reinterpret_cast<int *>(branchbuf.GetCurrent());
      for (Int_t idx=0; idx < count; idx++) {
         Int_t tmp = *reinterpret_cast<Int_t*>(&entry[idx]);
         char *tmp_ptr = reinterpret_cast<char *>(&tmp);
         int val;
         frombuf(tmp_ptr, &val);

         EXPECT_EQ(val, evt_idx);
         evt_idx++;
      }
   }
   sw.Stop();
   printf("GetEntriesSerialized: Successful read of all %lld events.\n", evt_idx);
   printf("GetEntriesSerialized: Total elapsed time (seconds) for bulk APIs: %.2f\n", sw.RealTime());
}


TEST(RRootBulkDS, ColTypeNames)
{
   RRootBulkDS tds(treeName, fileGlob);
   tds.SetNSlots(1);

   auto colNames = tds.GetColumnNames();

   EXPECT_TRUE(tds.HasColumn("i"));
   EXPECT_FALSE(tds.HasColumn("bla"));

   EXPECT_STREQ("i", colNames[0].c_str());

   EXPECT_STREQ("Int_t", tds.GetTypeName("i").c_str());
}


TEST(RRootBulkDS, EntryRanges)
{
   RRootBulkDS tds(treeName, fileGlob);
   tds.SetNSlots(3U);
   tds.Initialise();

   auto ranges = tds.GetEntryRanges();

   EXPECT_EQ(1U, ranges.size());
   EXPECT_EQ(0U, ranges[0].first);
   EXPECT_EQ(10U, ranges[0].second);
}

TEST(RRootBulkDS, ColumnReaders)
{
   RRootBulkDS tds(treeName, fileGlob);
   tds.SetNSlots(1);
   auto vals = tds.GetColumnReaders<int>("i");
   tds.Initialise();
   auto ranges = tds.GetEntryRanges();
   auto slot = 0U;
   for (auto &&range : ranges) {
      tds.InitSlot(slot, range.first);
      for (auto i : ROOT::TSeq<int>(range.first, range.second)) {
         tds.SetEntry(slot, i);
         auto val = **vals[slot];
         ASSERT_EQ(i, val);
      }
      slot++;
   }
}

TEST(RRootBulkDS, ColumnReadersWrongType)
{
   RRootBulkDS tds(treeName, fileGlob);
   tds.SetNSlots(1);
   int res = 1;
   try {
      auto vals = tds.GetColumnReaders<char *>("i");
   } catch (const std::runtime_error &e) {
      EXPECT_STREQ("The type of column \"i\" is Int_t but a different one has been selected.", e.what());
      res = 0;
   }
   EXPECT_EQ(0, res);
}

#ifndef NDEBUG

TEST(RRootBulkDS, SetNSlotsTwice)
{
   auto theTest = []() {
      RRootBulkDS tds(treeName, fileGlob);
      tds.SetNSlots(1);
      tds.SetNSlots(1);
   };
   ASSERT_DEATH(theTest(), "Setting the number of slots even if the number of slots is different from zero.");
}
#endif

#ifdef R__B64


TEST(RRootBulkDS, FromARDFWithJitting)
{
   std::unique_ptr<RDataSource> tds(new RRootBulkDS(treeName, fileGlob));
   RDataFrame tdf(std::move(tds));
   auto max = tdf.Filter("i<6").Max("i");
   auto min = tdf.Define("j", "i").Filter("j>4").Min("j");

   EXPECT_DOUBLE_EQ(5., *max);
   EXPECT_DOUBLE_EQ(5., *min);
}


TEST(RRootBulkDS, FromARDF)
{
   std::unique_ptr<RDataSource> tds(new RRootBulkDS(treeName, fileGlob));
   RDataFrame tdf(std::move(tds));
   auto max = tdf.Max<int>("i");
   auto min = tdf.Min<int>("i");
   auto c = tdf.Count();

   EXPECT_EQ(10U, *c);
   EXPECT_DOUBLE_EQ(9., *max);
   EXPECT_DOUBLE_EQ(0., *min);
}


// NOW MT!-------------
#ifdef R__USE_IMT

TEST(RootBulkDS, DefineSlotMT)
{
   ROOT::EnableImplicitMT(kSlots);

   std::vector<unsigned int> ids(kSlots, 0u);
   std::unique_ptr<RDataSource> tds(new RRootBulkDS(treeName, fileGlob));
   RDataFrame d(std::move(tds));
   auto m = d.DefineSlot("x", [&](unsigned int slot) {
                ids[slot] = 1u;
                return 1;
             }).Max("x");
   EXPECT_EQ(1, *m); // just in case

   const auto nUsedSlots = std::accumulate(ids.begin(), ids.end(), 0u);
   EXPECT_GT(nUsedSlots, 0u);
   EXPECT_LE(nUsedSlots, kSlots);
}

TEST(RRootBulkDS, FromARDFMT)
{
   ROOT::EnableImplicitMT(kSlots);

   std::unique_ptr<RDataSource> tds(new RRootBulkDS(treeName, fileGlob));
   RDataFrame tdf(std::move(tds));
   auto max = tdf.Max<int>("i");
   auto min = tdf.Min<int>("i");
   auto c = tdf.Count();

   EXPECT_EQ(10U, *c);
   EXPECT_DOUBLE_EQ(9., *max);
   EXPECT_DOUBLE_EQ(0., *min);
}

TEST(RRootBulkDS, FromARDFWithJittingMT)
{
   ROOT::EnableImplicitMT(kSlots);

   std::unique_ptr<RDataSource> tds(new RRootBulkDS(treeName, fileGlob));
   RDataFrame tdf(std::move(tds));
   auto max = tdf.Filter("i<6").Max("i");
   auto min = tdf.Define("j", "i").Filter("j>4").Min("j");

   EXPECT_DOUBLE_EQ(5., *max);
   EXPECT_DOUBLE_EQ(5., *min);
}

// Simple speed test
TEST(RRootBulkDS, BenchmarkBulkDS)
{
   auto hfile = TFile::Open(fileNameBig);
   printf("Starting read of file %s.\n", fileNameBig);
   TStopwatch sw;

   printf("Using inline bulk read APIs.\n");
   TBufferFile branchbuf(TBuffer::kWrite, 32*1024);
   TTree *tree = dynamic_cast<TTree*>(hfile->Get("t"));
   ASSERT_TRUE(tree);

   TBranch *branchI = tree->GetBranch("myInt");
   ASSERT_TRUE(branchI);

   Int_t events = bigEventCount;
   Long64_t evt_idx = 0;
   Int_t max_bulk = 0;
   while (events) {
      auto count = branchI->GetBulkRead().GetEntriesSerialized(evt_idx, branchbuf);
      ASSERT_EQ(count, bigFlushSize);
      events = events > count ? (events - count) : 0;

      int *entry = reinterpret_cast<int *>(branchbuf.GetCurrent());
      for (Int_t idx=0; idx < count; idx++) {
         Int_t tmp = *reinterpret_cast<Int_t*>(&entry[idx]);
         char *tmp_ptr = reinterpret_cast<char *>(&tmp);
         int val;
         frombuf(tmp_ptr, &val);

         //EXPECT_EQ(val, evt_idx+2);
         //evt_idx++;
         if (val > max_bulk) {max_bulk = val;}
      }
      evt_idx += count;
   }
   sw.Stop();
   EXPECT_EQ(max_bulk, bigEventCount+1);
   printf("GetEntriesSerialized: Successful read of all %lld events.\n", evt_idx);
   printf("GetEntriesSerialized: Total elapsed time (seconds) for bulk APIs: %.2f\n", sw.RealTime());

   printf("Using TTreeReaderFast.\n");
   hfile = TFile::Open(fileNameBig);
   printf("Starting read of file %s.\n", fileNameBig);

   ROOT::Experimental::TTreeReaderFast myReader(treeName, hfile);
   ROOT::Experimental::TTreeReaderValueFast<int> myInt(myReader, "myInt");
   myReader.SetEntry(0);
   if (ROOT::Internal::TTreeReaderValueBase::kSetupMatch != myInt.GetSetupStatus()) {
      printf("TTreeReaderValueFast<float> failed to initialize.  Status code: %d\n", myInt.GetSetupStatus());
      ASSERT_TRUE(false);
   }
   if (myReader.GetEntryStatus() != TTreeReader::kEntryValid) {
      printf("TTreeReaderFast failed to initialize.  Entry status: %d\n", myReader.GetEntryStatus());
      ASSERT_TRUE(false);
   }

   max_bulk = 0;
   sw.Reset();
   sw.Start();
   for (auto reader_idx : myReader) {
      (void)reader_idx;
      int val = *myInt;
      if (max_bulk < val) max_bulk = val;
   }
   sw.Stop();
   EXPECT_EQ(max_bulk, bigEventCount+1);
   printf("TTreeReaderFast: Successful read of all events.\n");
   printf("TTreeReaderFast: Total elapsed time (seconds): %.2f\n", sw.RealTime());

   RDataFrame tdf(treeName, fileNameBig, {"myInt"});

   printf("Using standard RDF APIs.\n");
   sw.Reset();
   sw.Start();
   auto max = tdf.Max<int>("myInt");
   //auto c = tdf.Count();

   EXPECT_EQ(bigEventCount+1, *max);
   sw.Stop();
   printf("Standard RDF APIs: Total elapsed time (seconds): %.2f\n", sw.RealTime());

   std::unique_ptr<RDataSource> rds2(new RRootBulkDS(treeName, fileNameBig));
   RDataFrame rdf2(std::move(rds2));

   printf("Using bulk RDS APIs.\n");
   sw.Reset();
   sw.Start();
   auto max2 = rdf2.Max<int>("myInt");
   //auto c = tdf.Count();

   EXPECT_EQ(bigEventCount+1, *max2);
   sw.Stop();
   printf("Using bulk RDS APIs: Total elapsed time (seconds): %.2f\n", sw.RealTime());

   printf("Using bulk data source directly.\n");
   RRootBulkDS tds(treeName, fileNameBig);
   tds.SetNSlots(1);
   auto vals = tds.GetColumnReaders<int>("myInt");
   tds.Initialise();
   auto ranges = tds.GetEntryRanges();
   auto slot = 0U;
   Int_t max3 = 0;
   sw.Reset();
   sw.Start();
   for (auto &&range : ranges) {
      tds.InitSlot(slot, range.first);
      for (int i = range.first; i < range.second; i++) {
         tds.SetEntry(slot, i);
         auto val = **vals[slot];
         if (val > max3) {max3 = val;}
      }
   }
   sw.Stop();
   //EXPECT_EQ(bigEventCount+1, max3);
   printf("Using bulk RDS directly: Total elapsed time (seconds): %.2f\n", sw.RealTime());
}

#endif // R__USE_IMT

#endif // R__B64
